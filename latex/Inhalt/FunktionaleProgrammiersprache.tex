\chapter{Funktionale Programmiersprache}
\section{Definition}
Die heutigen funktionalen Programmierparadigmen beruhen auf dem in den 1930er Jahren von Alonso Church und Stephen Kleene eingeführten Lambda-Kalkül. Es handelt sich dabei um eine formale Sprache um Funktionen zu untersuchen. Basierend darauf wurde 1960 von Marvin Minsky LISP entwickelt, die sozusagen erste funktionale Programmiersprache.

Heutzutage ist es schwer, eine allgemeingültige Definition für Funktionale Programmiersprachen zu finden, da funktionale Konzepte in sehr vielen Programmiersprachen vorkommen. In der Wikipedia wird der Begriff wie folgt definiert:

"Eine funktionale Programmiersprache ist eine Programmiersprache, die Sprachelemente zur Kombination und Transformation von Funktionen anbietet. Eine rein funktionale Programmiersprache ist eine Programmiersprache, die die Verwendung von Elementen ausschließt, die im Widerspruch zum funktionalen Programmierparadigma stehen." [[http://de.wikipedia.org/wiki/Funktionale\_Programmiersprache][]]

Der erste Teil der Definition trifft aber auf sehr viele Programmiersprachen zu, die man im Allgemeinen nicht als funktional bezeichnen würde. Der zweite Teil hingegen schließt unter Umständen sehr viele Sprachen aus, die man wiederum im Allgemeinen als funktional bezeichnen würde, je nach dem was man alles zum funktionalen Programmierparadigma zählt.

Im Gegensatz dazu umfasstttt die Definition der School of Computer Science Nottingham mehr die Sprachen, die auch umgangssprachlich als funktional bezeichnet werden.

"Functional programming is a style of programming that emphasizes the evaluation of expressions, rather than execution of commands. The expressions in these language are formed by using functions to combine basic values. A functional language is a language that supports and encourages programming in a functional style." [[http://www.cs.nott.ac.uk/~gmh/faq.html][]]

Die Betonung liegt hier auf \textbf{encourage}, also das Anregen oder Ermutigen, auf funktionale Weise zu Programmieren. Damit werden all die Sprachen aus der Definition ausgeschlossen, die nur aus einem imperativen Ansatz heraus funktionale Elemente implementieren.

\section{Vorteile}
\begin{itemize}
\item \textbf{Andere Sichtweise auf Probleme:} Man versucht nicht, wie bei imperativer Programmierung, zu beschreiben, welche Operationen auf dem Speicher ausgeführt werden, sondern man versucht vielmehr den Lösungsweg selber anzugeben. Diese Sichtweise kann dann durchaus auch bei der Programmierung in imperativen Sprachen helfen, sofern diese funktionale Konzepte zumindest Teilweise unterstützen. Das ist aber bei sehr vielen weit verbreiteten Sprachen der Fall.
\item \textbf{Eleganter:} Die meisten Problemlösungen sind deutlich kürzer und eleganter wenn man sie funktional implementiert, da kein Zustand betrachtet werden muss. Der Code ist deshalb auch übersichtlicher.
\item \textbf{Debuggen und Testen einfacher:} In rein funktionalen Programmiersprachen müssen weder Seiteneffekte noch Zustände berücksichtigt werden. Beim Debuggen können Fehler deshalb unabhängig vom Speicherzustand betrachtet werden. Durch die hohe Modularität kann man auch sehr einfach einzelne Funktionen testen. 
\item \textbf{Einfache Syntax:} Im Allgemeinen haben funktionale Programmiersprachen eine einfachere Syntax als imperative Programmiersprachen, da sie  mit wenigen syntaktischen Konstrukten und wenigen Schlüsselwörtern auskommen. 
\item \textbf{Modularisierung:} Ein Problem kann soweit zerlegt werden, dass es nur noch aus simplen Funktionen besteht, die dann wiederum in anderen Problemlösungen verwendet werden können.
\item \textbf{Parallelisierbarkeit:} Einzelne Teilausdrücke können ohne Probleme parallel ausgewertet werden. Das ist insbesondere ein großer Vorteil bei der Programmierung für Multi-Core-Systeme.
\end{itemize}
