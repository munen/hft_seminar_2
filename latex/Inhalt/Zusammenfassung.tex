\chapter{Zusammenfassung}
\section{Alleinstellungsmerkmale}
Ein wirklich Alleinstellungsmerkmal im klassischen Sinne ist bei Clojure schwer zu finden. Es ist vielmehr die Kombination von schon vorhandenen Elementen, die es so noch nicht gibt. Es gibt andere funktionale und dynamische Sprachen, LISP-Dialekte sowie Sprachen die sich sehr gut zur Lösung von Nebenläufigkeitsproblemen eignen. Und das alles gibt es sogar auf der JVM. Aber es gab bisher keine Sprache, die das alles Vereint.

\section{Einsatzgebiete}
Prinzipiell lässt sich jedes Problem mit jeder Programmiersprache lösen, solange diese Turing complete ist. Es gibt aber sehr große Unterschiede, was den Aufwand betrifft, den man dafür betreiben muss. Und der Aufwand beinhaltet nicht nur das schreiben des Codes selbst, sondern auch die Installation einer Laufzeitumgebung oder das Compilieren für unterschiedliche Plattformen.

Durch die Bindung an die JVM macht der Einsatz von Clojure schon einmal insbesondere da Sinn, wo schon mit einer Java Umgebung gearbeitet wird. So erspart man sich die Wartung einer separaten Laufzeitumgebung. Warum dann nicht gleich Java? In Bereichen wo viel mit Nebenläufigkeit gearbeitet wird, kann man sehr einfach auf Locks, sychronized-Blöcke, Race Conditions, explizit als volatil zu deklarierende Instanzvariablen oder ConcurrentModificationExceptions verzichten, wenn man auf Clojure setzt. Der allgemeine Entwicklungsablauf ist in Clojure durch die REPL auch deutlich dynamischer und interaktiver als in Java.

Clojure eignet sich auch hervorragend zur Lösung Mathematischer Probleme, da das funktionale Konzept erheblich näher an die Mathematik angelehnt ist, als imperative Konzepte. Funktionen in Closure entsprechen auch eher einer mathematischen Funktion als z.B. Funktionen in C.