5
-

* JVM: interessante Platform
  * Performanz
  * ubiquitaer
  * "business-proof"

* Sprachportierungen: jRuby, Jython, etc

6
-

* Multithreading Schwachstelle imperativer Ansatz
 * Locking
 * Implementierung (Ruby/Python GIL[Global Interpreter Lock])
 * Fehleranfaellig

* Funktionale Vorteile
 * Immutability
 * Listen, map, filter, reduce -> Keine Variable

* LISP
 * Konziser Code Macros
  * Durch Uebersichtlichkeit weniger fehleranfaellig
 

* Clojure
 * Software Transactional Memory
 * Laziness
 * Closures


* Code Beispiel
 * Darstellung von Nebenlaeufigkeit
 * Moeglichkeiten
  * Heuristischer Algorithmus (Agenten)
  * Zellulaerer Automat (Brians Brain, Game of Life)
  * Sortier Algorithmen
 * Vorteile Locking vs. echte Nebenlaeufigkeit herausstellen

